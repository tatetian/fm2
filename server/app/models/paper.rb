class Paper < ActiveRecord::Base
  attr_accessible :abstract, :authors, :content, :convert, :date, :docid, :publication, :title
  has_many :comments, dependent: :destroy
  has_many :metadatas, dependent: :destroy
  has_many :notes, dependent: :destroy
  has_many :highlights, dependent: :destroy

  validates   :docid, presence: true, uniqueness: {case_sensitive:true}
  validates   :title, presence: true
  
  def getComments
      result = self.comments
  end
  def getNotes(params={}) 
      if params.has_key?(:user_id)
          user_id = params[:user_id]
          notes = Note.all(:conditions=>{:user_id=>user_id,:paper_id=>self.id})
      else
          notes = self.notes
      end
  end
  def getHighlights(params={}) 
      if params.has_key?(:user_id)
          user_id = params[:user_id]
          result = Highlight.all(:conditions=>{:paper_id=>self.id,:user_id=>user_id})
      else
         result = self.highlights
      end
  end

  # Return Paper record given its SHA-1 hash
  def self.find_by_sha1 sha1
    begin
      # Get the UUID
      #   Because we only calculate the SHA-1 in browswer
      #   (for the sake of convinence) and UUID is saved in database not SHA-1, 
      #   we have to convert to SHA-1 value to UUID
      uuid = _sha1_to_uuid sha1
      Paper.find_by_docid(uuid)
    rescue
      # If anything wrong, return false
      nil
    end
  end

  # Calculate the UUID of a file given its file path
  #   UUID which is encoded in Base64 is generated by truncating SHA-1 hash
  def self.calculate_uuid(f)
    # Use SHA-1 to calculate a hash for the file
    # e.g. "74e10ff37b568e76c5166ce8b0eddf2abfdcbac9"
    require 'digest/sha1'
    sha1 = Digest::SHA1.hexdigest(File.read(f)).to_s
    # Convert SHA-1 value to UUID
    # e.g. "dOEP83tWjnbFFmzosO3fKg"
    Paper.sha1_to_uuid sha1
  end

  def self.sha1_to_uuid(sha1) 
    # Truncate SHA-1 to UUID
    #   SHA-1 is 160-bit, UUID is 128-bit
    #   So we want the first 32 HEX digits (128/4=32)
    #   Although this uuid is same as version 5 UUID in essence, 
    #   they are not equal.
    # e.g. "74e10ff37b568e76c5166ce8b0eddf2a"
    shorter = sha1[0...32]
    # Get bytes representation of uuid
    # e.g. "t\xE1\x0F\xF3{V\x8Ev\xC5\x16l\xE8\xB0\xED\xDF*"
    bytes = [shorter].pack("H*")
    # Encode the bytes of uuid in Base64 encoding for shorter representation
    # e.g. "dOEP83tWjnbFFmzosO3fKg=="
    require "base64"
    base64 = Base64.urlsafe_encode64(bytes)
    # Discard the trailing '==' 
    #   In base 64 encoding, the trailing '=' is padding
    #     '==' indicates that the last group contains only 1 bytes
    #     '=' indicates that the last group contains 2 bytes
    # e.g. "dOEP83tWjnbFFmzosO3fKg"
    res = base64[0...-2]
  end

end
